# Transformer Support Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add full Shiki transformer support to shiki-highlight-api while maintaining 80-90% DOM node reduction.

**Architecture:** Extract metadata from HAST tree generated by Shiki transformers, then apply metadata to Highlight API HTML/CSS generation. Fast path preserved when no transformers present.

**Tech Stack:** TypeScript, Shiki v3, unist-util-visit for HAST traversal, Vitest for testing

---

## Task 1: Add HAST Dependencies and Types

**Files:**

- Modify: `package.json`
- Create: `src/metadata.ts`

**Step 1: Add HAST dependency**

Add to package.json dependencies:

```json
{
  "dependencies": {
    "shiki": "^3.14.0",
    "unist-util-visit": "^5.0.0",
    "hast-util-to-string": "^3.0.0"
  }
}
```

Run: `npm install`

**Step 2: Create metadata types file**

Create `src/metadata.ts`:

```typescript
/**
 * Metadata extracted from HAST tree for applying to Highlight API output
 */
export interface Metadata {
  /** Whether to show line numbers */
  lineNumbers: boolean | { start: number };

  /** Line numbers to highlight */
  highlightedLines: Set<number>;

  /** Lines with diff markers */
  diffLines: {
    added: Set<number>;
    removed: Set<number>;
  };

  /** Lines that should be in focus (others dimmed) */
  focusLines: Set<number>;

  /** Custom CSS classes per line */
  lineClasses: Map<number, string[]>;

  /** Custom inline styles per line */
  lineStyles: Map<number, Record<string, string>>;
}

/**
 * Create empty metadata object
 */
export function createEmptyMetadata(): Metadata {
  return {
    lineNumbers: false,
    highlightedLines: new Set(),
    diffLines: { added: new Set(), removed: new Set() },
    focusLines: new Set(),
    lineClasses: new Map(),
    lineStyles: new Map(),
  };
}
```

**Step 3: Commit**

```bash
git add package.json package-lock.json src/metadata.ts
git commit -m "feat: add HAST dependencies and metadata types"
```

---

## Task 2: Implement HAST Metadata Extraction

**Files:**

- Modify: `src/metadata.ts`
- Create: `test/metadata-extraction.test.ts`

**Step 1: Write test for basic metadata extraction**

Create `test/metadata-extraction.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { extractMetadata } from '../src/metadata';
import type { Element, Root } from 'hast';

describe('extractMetadata', () => {
  it('extracts highlighted lines from HAST', () => {
    const hast: Root = {
      type: 'root',
      children: [
        {
          type: 'element',
          tagName: 'pre',
          properties: {},
          children: [
            {
              type: 'element',
              tagName: 'code',
              properties: {},
              children: [
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line', 'highlighted'],
                    'data-line': '1',
                  },
                  children: [],
                },
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line'],
                    'data-line': '2',
                  },
                  children: [],
                },
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line', 'highlighted'],
                    'data-line': '3',
                  },
                  children: [],
                },
              ],
            },
          ],
        },
      ],
    };

    const metadata = extractMetadata(hast);

    expect(metadata.highlightedLines).toEqual(new Set([1, 3]));
  });

  it('extracts diff lines from HAST', () => {
    const hast: Root = {
      type: 'root',
      children: [
        {
          type: 'element',
          tagName: 'pre',
          properties: {},
          children: [
            {
              type: 'element',
              tagName: 'code',
              properties: {},
              children: [
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line', 'diff', 'add'],
                    'data-line': '1',
                  },
                  children: [],
                },
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line', 'diff', 'remove'],
                    'data-line': '2',
                  },
                  children: [],
                },
              ],
            },
          ],
        },
      ],
    };

    const metadata = extractMetadata(hast);

    expect(metadata.diffLines.added).toEqual(new Set([1]));
    expect(metadata.diffLines.removed).toEqual(new Set([2]));
  });

  it('extracts focus lines from HAST', () => {
    const hast: Root = {
      type: 'root',
      children: [
        {
          type: 'element',
          tagName: 'pre',
          properties: {},
          children: [
            {
              type: 'element',
              tagName: 'code',
              properties: {},
              children: [
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line', 'focused'],
                    'data-line': '1',
                  },
                  children: [],
                },
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line'],
                    'data-line': '2',
                  },
                  children: [],
                },
              ],
            },
          ],
        },
      ],
    };

    const metadata = extractMetadata(hast);

    expect(metadata.focusLines).toEqual(new Set([1]));
  });

  it('returns empty metadata for HAST without annotations', () => {
    const hast: Root = {
      type: 'root',
      children: [
        {
          type: 'element',
          tagName: 'pre',
          properties: {},
          children: [
            {
              type: 'element',
              tagName: 'code',
              properties: {},
              children: [
                {
                  type: 'element',
                  tagName: 'span',
                  properties: {
                    class: ['line'],
                    'data-line': '1',
                  },
                  children: [],
                },
              ],
            },
          ],
        },
      ],
    };

    const metadata = extractMetadata(hast);

    expect(metadata.highlightedLines.size).toBe(0);
    expect(metadata.diffLines.added.size).toBe(0);
    expect(metadata.diffLines.removed.size).toBe(0);
    expect(metadata.focusLines.size).toBe(0);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test test/metadata-extraction.test.ts`
Expected: FAIL - extractMetadata function not found

**Step 3: Implement extractMetadata function**

Add to `src/metadata.ts`:

```typescript
import { visit } from 'unist-util-visit';
import type { Root, Element } from 'hast';

/**
 * Extract metadata from HAST tree generated by Shiki transformers
 */
export function extractMetadata(hast: Root): Metadata {
  const metadata = createEmptyMetadata();

  visit(hast, 'element', (node: Element) => {
    if (node.tagName === 'span' && Array.isArray(node.properties.class)) {
      const classes = node.properties.class as string[];

      if (!classes.includes('line')) {
        return;
      }

      const lineNum = parseInt(String(node.properties['data-line'] || '0'));
      if (lineNum === 0) {
        return;
      }

      // Extract highlighted lines
      if (classes.includes('highlighted')) {
        metadata.highlightedLines.add(lineNum);
      }

      // Extract diff lines
      if (classes.includes('diff')) {
        if (classes.includes('add')) {
          metadata.diffLines.added.add(lineNum);
        }
        if (classes.includes('remove')) {
          metadata.diffLines.removed.add(lineNum);
        }
      }

      // Extract focus lines
      if (classes.includes('focused') || classes.includes('has-focus')) {
        metadata.focusLines.add(lineNum);
      }

      // Store all classes for custom transformers
      metadata.lineClasses.set(lineNum, classes);

      // Extract inline styles if present
      if (node.properties.style && typeof node.properties.style === 'string') {
        metadata.lineStyles.set(lineNum, parseInlineStyles(node.properties.style));
      }
    }
  });

  return metadata;
}

/**
 * Parse inline style string into object
 */
function parseInlineStyles(styleString: string): Record<string, string> {
  const styles: Record<string, string> = {};

  styleString.split(';').forEach((rule) => {
    const [prop, value] = rule.split(':').map((s) => s.trim());
    if (prop && value) {
      styles[prop] = value;
    }
  });

  return styles;
}
```

**Step 4: Run test to verify it passes**

Run: `npm test test/metadata-extraction.test.ts`
Expected: PASS - all tests pass

**Step 5: Commit**

```bash
git add src/metadata.ts test/metadata-extraction.test.ts
git commit -m "feat: implement HAST metadata extraction"
```

---

## Task 3: Update HighlightOptions Interface

**Files:**

- Modify: `src/index.ts`

**Step 1: Add new options to interface**

In `src/index.ts`, update the HighlightOptions interface:

```typescript
import type { ShikiTransformer } from 'shiki';

export interface HighlightOptions {
  /** Language identifier (e.g., 'javascript', 'python', 'rust') */
  lang: string;
  /** Shiki theme name (default: 'dark-plus') */
  theme?: string;
  /** Optional unique block ID (auto-generated if omitted) */
  blockId?: string;

  // NEW: Transformer support
  /** Shiki transformers to apply */
  transformers?: ShikiTransformer[];

  // NEW: Convenience options (converted to transformers internally)
  /** Show line numbers */
  lineNumbers?: boolean | { start?: number };
  /** Line numbers to highlight (array or string like "1,3,5-7") */
  highlightLines?: number[] | string;
  /** Lines with diff markers */
  diffLines?: {
    added?: number[];
    removed?: number[];
  };
  /** Lines to keep in focus (others dimmed) */
  focusLines?: number[];
}
```

**Step 2: Commit**

```bash
git add src/index.ts
git commit -m "feat: add transformer options to HighlightOptions interface"
```

---

## Task 4: Implement Line Number Parser

**Files:**

- Create: `src/line-parser.ts`
- Create: `test/line-parser.test.ts`

**Step 1: Write tests for line number parsing**

Create `test/line-parser.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { parseLineNumbers } from '../src/line-parser';

describe('parseLineNumbers', () => {
  it('parses array of numbers', () => {
    expect(parseLineNumbers([1, 3, 5])).toEqual([1, 3, 5]);
  });

  it('parses comma-separated string', () => {
    expect(parseLineNumbers('1,3,5')).toEqual([1, 3, 5]);
  });

  it('parses range syntax', () => {
    expect(parseLineNumbers('1-3')).toEqual([1, 2, 3]);
  });

  it('parses mixed syntax', () => {
    expect(parseLineNumbers('1,3,5-7,10')).toEqual([1, 3, 5, 6, 7, 10]);
  });

  it('handles whitespace', () => {
    expect(parseLineNumbers('1, 3, 5-7')).toEqual([1, 3, 5, 6, 7]);
  });

  it('returns empty array for empty input', () => {
    expect(parseLineNumbers([])).toEqual([]);
    expect(parseLineNumbers('')).toEqual([]);
  });

  it('deduplicates line numbers', () => {
    expect(parseLineNumbers('1,1,2,2,3')).toEqual([1, 2, 3]);
  });

  it('sorts line numbers', () => {
    expect(parseLineNumbers('5,1,3')).toEqual([1, 3, 5]);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test test/line-parser.test.ts`
Expected: FAIL - parseLineNumbers not found

**Step 3: Implement parseLineNumbers function**

Create `src/line-parser.ts`:

```typescript
/**
 * Parse line numbers from array or string format
 * Supports: [1,3,5], "1,3,5", "1-3", "1,3,5-7"
 */
export function parseLineNumbers(input: number[] | string): number[] {
  if (Array.isArray(input)) {
    return [...new Set(input)].sort((a, b) => a - b);
  }

  if (!input || input.trim() === '') {
    return [];
  }

  const lines = new Set<number>();

  input.split(',').forEach((part) => {
    const trimmed = part.trim();

    if (trimmed.includes('-')) {
      // Range: "1-3"
      const [start, end] = trimmed.split('-').map((n) => parseInt(n.trim()));
      if (!isNaN(start) && !isNaN(end)) {
        for (let i = start; i <= end; i++) {
          lines.add(i);
        }
      }
    } else {
      // Single number: "5"
      const num = parseInt(trimmed);
      if (!isNaN(num)) {
        lines.add(num);
      }
    }
  });

  return [...lines].sort((a, b) => a - b);
}
```

**Step 4: Run test to verify it passes**

Run: `npm test test/line-parser.test.ts`
Expected: PASS - all tests pass

**Step 5: Commit**

```bash
git add src/line-parser.ts test/line-parser.test.ts
git commit -m "feat: implement line number parser"
```

---

## Task 5: Implement buildTransformers Helper

**Files:**

- Create: `src/transformer-builder.ts`
- Create: `test/transformer-builder.test.ts`

**Step 1: Write tests for transformer builder**

Create `test/transformer-builder.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { buildTransformers } from '../src/transformer-builder';
import type { HighlightOptions } from '../src/index';

describe('buildTransformers', () => {
  it('returns empty array when no transformer options', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
    };

    const transformers = buildTransformers(options);

    expect(transformers).toEqual([]);
  });

  it('includes explicit transformers', () => {
    const customTransformer = { name: 'custom' };
    const options: HighlightOptions = {
      lang: 'javascript',
      transformers: [customTransformer as any],
    };

    const transformers = buildTransformers(options);

    expect(transformers).toContain(customTransformer);
  });

  it('converts lineNumbers option to transformer', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      lineNumbers: true,
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(0);
    // Line numbers transformer will be added
  });

  it('converts highlightLines array to transformer', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      highlightLines: [1, 3, 5],
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(0);
  });

  it('converts highlightLines string to transformer', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      highlightLines: '1,3,5-7',
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(0);
  });

  it('converts diffLines to transformer', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      diffLines: {
        added: [1, 3],
        removed: [2, 4],
      },
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(0);
  });

  it('converts focusLines to transformer', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      focusLines: [1, 2, 3],
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(0);
  });

  it('combines multiple options into transformers', () => {
    const options: HighlightOptions = {
      lang: 'javascript',
      lineNumbers: true,
      highlightLines: [1, 3],
      diffLines: { added: [5] },
    };

    const transformers = buildTransformers(options);

    expect(transformers.length).toBeGreaterThan(2);
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test test/transformer-builder.test.ts`
Expected: FAIL - buildTransformers not found

**Step 3: Implement buildTransformers function**

Create `src/transformer-builder.ts`:

```typescript
import type { ShikiTransformer } from 'shiki';
import type { HighlightOptions } from './index';
import { parseLineNumbers } from './line-parser';

/**
 * Build array of Shiki transformers from options
 */
export function buildTransformers(options: HighlightOptions): ShikiTransformer[] {
  const transformers: ShikiTransformer[] = [...(options.transformers || [])];

  // Add line number transformer
  if (options.lineNumbers) {
    transformers.push(createLineNumberTransformer(options.lineNumbers));
  }

  // Add highlight lines transformer
  if (options.highlightLines) {
    const lines = Array.isArray(options.highlightLines)
      ? options.highlightLines
      : parseLineNumbers(options.highlightLines);
    transformers.push(createHighlightLinesTransformer(lines));
  }

  // Add diff transformer
  if (options.diffLines) {
    transformers.push(createDiffTransformer(options.diffLines));
  }

  // Add focus transformer
  if (options.focusLines) {
    transformers.push(createFocusTransformer(options.focusLines));
  }

  return transformers;
}

/**
 * Create transformer for line numbers
 */
function createLineNumberTransformer(lineNumbers: boolean | { start?: number }): ShikiTransformer {
  const start = typeof lineNumbers === 'object' ? lineNumbers.start || 1 : 1;

  return {
    name: 'line-numbers',
    line(node, line) {
      node.properties['data-line'] = String(line);
      return node;
    },
  };
}

/**
 * Create transformer for highlighted lines
 */
function createHighlightLinesTransformer(lines: number[]): ShikiTransformer {
  const lineSet = new Set(lines);

  return {
    name: 'highlight-lines',
    line(node, line) {
      if (lineSet.has(line)) {
        node.properties.class = node.properties.class || [];
        if (Array.isArray(node.properties.class)) {
          node.properties.class.push('highlighted');
        }
      }
      return node;
    },
  };
}

/**
 * Create transformer for diff lines
 */
function createDiffTransformer(diffLines: {
  added?: number[];
  removed?: number[];
}): ShikiTransformer {
  const added = new Set(diffLines.added || []);
  const removed = new Set(diffLines.removed || []);

  return {
    name: 'diff-lines',
    line(node, line) {
      if (added.has(line) || removed.has(line)) {
        node.properties.class = node.properties.class || [];
        if (Array.isArray(node.properties.class)) {
          node.properties.class.push('diff');
          if (added.has(line)) {
            node.properties.class.push('add');
          }
          if (removed.has(line)) {
            node.properties.class.push('remove');
          }
        }
      }
      return node;
    },
  };
}

/**
 * Create transformer for focus lines
 */
function createFocusTransformer(lines: number[]): ShikiTransformer {
  const lineSet = new Set(lines);

  return {
    name: 'focus-lines',
    line(node, line) {
      if (lineSet.has(line)) {
        node.properties.class = node.properties.class || [];
        if (Array.isArray(node.properties.class)) {
          node.properties.class.push('focused');
        }
      }
      return node;
    },
  };
}
```

**Step 4: Run test to verify it passes**

Run: `npm test test/transformer-builder.test.ts`
Expected: PASS - all tests pass

**Step 5: Commit**

```bash
git add src/transformer-builder.ts test/transformer-builder.test.ts
git commit -m "feat: implement transformer builder"
```

---

## Task 6: Update HTML Generation with Metadata

**Files:**

- Modify: `src/index.ts`
- Create: `test/html-generation-metadata.test.ts`

**Step 1: Write tests for HTML generation with metadata**

Create `test/html-generation-metadata.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { codeToHighlightHtml } from '../src/index';

describe('HTML generation with metadata', () => {
  it('adds line-number spans when lineNumbers enabled', async () => {
    const code = 'const x = 1;\nconst y = 2;';
    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
      lineNumbers: true,
    });

    expect(result.html).toContain('line-number');
    expect(result.html).toContain('>1</span>');
    expect(result.html).toContain('>2</span>');
  });

  it('starts line numbers from custom start value', async () => {
    const code = 'const x = 1;';
    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
      lineNumbers: { start: 5 },
    });

    expect(result.html).toContain('>5</span>');
  });

  it('adds highlighted class to specified lines', async () => {
    const code = 'line1\nline2\nline3';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      highlightLines: [1, 3],
    });

    expect(result.html).toContain('class="line highlighted"');
  });

  it('adds diff markers for added lines', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      diffLines: { added: [1] },
    });

    expect(result.html).toContain('diff add');
    expect(result.html).toContain('diff-marker">+</span>');
  });

  it('adds diff markers for removed lines', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      diffLines: { removed: [2] },
    });

    expect(result.html).toContain('diff remove');
    expect(result.html).toContain('diff-marker">-</span>');
  });

  it('adds blurred class to non-focused lines', async () => {
    const code = 'line1\nline2\nline3';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      focusLines: [1, 2],
    });

    expect(result.html).toContain('blurred');
  });

  it('combines line numbers with highlights', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      lineNumbers: true,
      highlightLines: [1],
    });

    expect(result.html).toContain('line-number');
    expect(result.html).toContain('highlighted');
  });

  it('uses fast path when no transformer options', async () => {
    const code = 'const x = 1;';
    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
    });

    expect(result.html).not.toContain('line-number');
    expect(result.html).not.toContain('highlighted');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test test/html-generation-metadata.test.ts`
Expected: FAIL - HTML does not contain metadata classes

**Step 3: Update generateHtml function**

In `src/index.ts`, update the `generateHtml` function to accept metadata:

```typescript
import type { Metadata } from './metadata';

/**
 * Generate clean HTML with single text node per line
 */
function generateHtml(code: string, blockId: string, metadata?: Metadata): string {
  const lines = code.split('\n');

  const linesHtml = lines
    .map((line, i) => {
      const lineNum = i + 1;
      const lineId = `${blockId}-L${i}`;

      // Build CSS classes
      const classes = ['line'];

      if (metadata) {
        if (metadata.highlightedLines.has(lineNum)) {
          classes.push('highlighted');
        }
        if (metadata.diffLines.added.has(lineNum)) {
          classes.push('diff', 'add');
        }
        if (metadata.diffLines.removed.has(lineNum)) {
          classes.push('diff', 'remove');
        }
        if (metadata.focusLines.size > 0 && !metadata.focusLines.has(lineNum)) {
          classes.push('blurred');
        }

        // Add custom classes from transformers
        const customClasses = metadata.lineClasses.get(lineNum);
        if (customClasses) {
          customClasses.forEach((cls) => {
            if (!classes.includes(cls)) {
              classes.push(cls);
            }
          });
        }
      }

      // Escape HTML entities
      const escaped = line
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

      let lineContent = '';

      // Add diff marker if needed
      if (metadata) {
        if (metadata.diffLines.added.has(lineNum)) {
          lineContent += '<span class="diff-marker">+</span>';
        } else if (metadata.diffLines.removed.has(lineNum)) {
          lineContent += '<span class="diff-marker">-</span>';
        }
      }

      // Add line number if enabled
      if (metadata && metadata.lineNumbers) {
        const start =
          typeof metadata.lineNumbers === 'object' ? metadata.lineNumbers.start || 1 : 1;
        lineContent += `<span class="line-number">${start + i}</span>`;
      }

      // Add code content
      lineContent += `<span class="line-content">${escaped}</span>`;

      return `<span id="${lineId}" class="${classes.join(' ')}">${lineContent}</span>`;
    })
    .join('\n');

  return `<pre class="shiki" data-highlight-block="${blockId}"><code>${linesHtml}</code></pre>`;
}
```

**Step 4: Update codeToHighlightHtml to use hybrid path**

In `src/index.ts`, update `codeToHighlightHtml`:

```typescript
import { buildTransformers } from './transformer-builder';
import { extractMetadata } from './metadata';

export async function codeToHighlightHtml(
  code: string,
  options: HighlightOptions
): Promise<HighlightResult> {
  const { lang, theme = 'dark-plus', blockId = generateId() } = options;

  // Build transformers from options
  const transformers = buildTransformers(options);

  // Get highlighter instance
  const highlighter = await getHighlighter();

  // Fast path: no transformers
  if (transformers.length === 0) {
    const tokens = highlighter.codeToTokens(code, {
      lang: lang as BundledLanguage,
      theme,
    });

    const html = generateHtml(code, blockId);
    const css = generateCss(tokens.tokens, theme, blockId);
    const script = generateScript(tokens.tokens, blockId);

    const stats = {
      tokens: tokens.tokens.flat().length,
      lines: tokens.tokens.length,
      uniqueStyles: new Set(tokens.tokens.flat().map((t) => t.color)).size,
    };

    return { html, css, script, stats };
  }

  // Hybrid path: with transformers
  try {
    // Generate HAST with transformers
    const hast = highlighter.codeToHast(code, {
      lang: lang as BundledLanguage,
      theme,
      transformers,
    });

    // Extract metadata from HAST
    const metadata = extractMetadata(hast);

    // Get tokens for highlighting
    const tokens = highlighter.codeToTokens(code, {
      lang: lang as BundledLanguage,
      theme,
    });

    // Generate output with metadata
    const html = generateHtml(code, blockId, metadata);
    const css = generateCss(tokens.tokens, theme, blockId, metadata);
    const script = generateScript(tokens.tokens, blockId);

    const stats = {
      tokens: tokens.tokens.flat().length,
      lines: tokens.tokens.length,
      uniqueStyles: new Set(tokens.tokens.flat().map((t) => t.color)).size,
    };

    return { html, css, script, stats };
  } catch (error) {
    // Fallback to fast path on error
    console.warn('Transformer processing failed, falling back to basic highlighting:', error);

    const tokens = highlighter.codeToTokens(code, {
      lang: lang as BundledLanguage,
      theme,
    });

    const html = generateHtml(code, blockId);
    const css = generateCss(tokens.tokens, theme, blockId);
    const script = generateScript(tokens.tokens, blockId);

    const stats = {
      tokens: tokens.tokens.flat().length,
      lines: tokens.tokens.length,
      uniqueStyles: new Set(tokens.tokens.flat().map((t) => t.color)).size,
    };

    return { html, css, script, stats };
  }
}
```

**Step 5: Run test to verify it passes**

Run: `npm test test/html-generation-metadata.test.ts`
Expected: PASS - all tests pass

**Step 6: Commit**

```bash
git add src/index.ts test/html-generation-metadata.test.ts
git commit -m "feat: update HTML generation with metadata support"
```

---

## Task 7: Update CSS Generation with Metadata

**Files:**

- Modify: `src/index.ts`
- Create: `test/css-generation-metadata.test.ts`

**Step 1: Write tests for CSS generation with metadata**

Create `test/css-generation-metadata.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { codeToHighlightHtml } from '../src/index';

describe('CSS generation with metadata', () => {
  it('includes line number styles when enabled', async () => {
    const code = 'const x = 1;';
    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
      lineNumbers: true,
    });

    expect(result.css).toContain('.line-number');
    expect(result.css).toContain('user-select: none');
  });

  it('includes highlight styles when lines highlighted', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      highlightLines: [1],
    });

    expect(result.css).toContain('.highlighted');
    expect(result.css).toContain('background-color');
  });

  it('includes diff styles when diff lines present', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      diffLines: { added: [1], removed: [2] },
    });

    expect(result.css).toContain('.diff.add');
    expect(result.css).toContain('.diff.remove');
    expect(result.css).toContain('.diff-marker');
  });

  it('includes focus styles when focus lines present', async () => {
    const code = 'line1\nline2';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      focusLines: [1],
    });

    expect(result.css).toContain('.blurred');
    expect(result.css).toContain('opacity');
  });

  it('scopes styles to block ID', async () => {
    const code = 'line1';
    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      blockId: 'test-block',
      highlightLines: [1],
    });

    expect(result.css).toContain('[data-highlight-block="test-block"]');
  });

  it('includes token highlight styles', async () => {
    const code = 'const x = 1;';
    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
      lineNumbers: true,
    });

    expect(result.css).toContain('::highlight(');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `npm test test/css-generation-metadata.test.ts`
Expected: FAIL - CSS does not contain metadata styles

**Step 3: Update generateCss function**

In `src/index.ts`, update the `generateCss` function:

```typescript
function generateCss(
  tokens: ThemedToken[][],
  theme: string,
  blockId: string,
  metadata?: Metadata
): string {
  // Generate token color rules (existing)
  const colorMap = new Map<string, string>();
  let colorIndex = 0;

  tokens.flat().forEach((token) => {
    if (token.color && !colorMap.has(token.color)) {
      const highlightName = `hl-${blockId}-${colorIndex++}`;
      colorMap.set(token.color, highlightName);
    }
  });

  const tokenRules = Array.from(colorMap.entries())
    .map(([color, name]) => {
      return `::highlight(${name}) { color: ${color}; }`;
    })
    .join('\n');

  // Generate metadata styles (new)
  const lineStyles: string[] = [];

  if (metadata) {
    // Line highlighting styles
    if (metadata.highlightedLines.size > 0) {
      lineStyles.push(
        `
[data-highlight-block="${blockId}"] .line.highlighted {
  background-color: rgba(255, 255, 0, 0.1);
  border-left: 3px solid rgba(255, 255, 0, 0.5);
  padding-left: 0.5em;
}
      `.trim()
      );
    }

    // Diff line styles
    if (metadata.diffLines.added.size > 0 || metadata.diffLines.removed.size > 0) {
      lineStyles.push(
        `
[data-highlight-block="${blockId}"] .line.diff.add {
  background-color: rgba(0, 255, 0, 0.1);
}
[data-highlight-block="${blockId}"] .line.diff.remove {
  background-color: rgba(255, 0, 0, 0.1);
  text-decoration: line-through;
}
[data-highlight-block="${blockId}"] .diff-marker {
  display: inline-block;
  width: 1ch;
  text-align: center;
  user-select: none;
}
[data-highlight-block="${blockId}"] .line.diff.add .diff-marker {
  color: #22c55e;
}
[data-highlight-block="${blockId}"] .line.diff.remove .diff-marker {
  color: #ef4444;
}
      `.trim()
      );
    }

    // Focus/blur styles
    if (metadata.focusLines.size > 0) {
      lineStyles.push(
        `
[data-highlight-block="${blockId}"] .line.blurred {
  opacity: 0.3;
  filter: blur(0.5px);
}
      `.trim()
      );
    }

    // Line number styles
    if (metadata.lineNumbers) {
      lineStyles.push(
        `
[data-highlight-block="${blockId}"] .line-number {
  display: inline-block;
  width: 3ch;
  text-align: right;
  margin-right: 1em;
  color: #6e7681;
  user-select: none;
}
      `.trim()
      );
    }

    // Custom line styles
    if (metadata.lineStyles.size > 0) {
      metadata.lineStyles.forEach((styles, lineNum) => {
        const styleStr = Object.entries(styles)
          .map(([prop, val]) => `${prop}: ${val}`)
          .join('; ');
        lineStyles.push(
          `
[data-highlight-block="${blockId}"] #${blockId}-L${lineNum - 1} {
  ${styleStr}
}
        `.trim()
        );
      });
    }
  }

  const allStyles = [tokenRules, ...lineStyles].filter((s) => s).join('\n');

  return `<style data-highlight-styles="${blockId}">\n${allStyles}\n</style>`;
}
```

**Step 4: Run test to verify it passes**

Run: `npm test test/css-generation-metadata.test.ts`
Expected: PASS - all tests pass

**Step 5: Commit**

```bash
git add src/index.ts test/css-generation-metadata.test.ts
git commit -m "feat: update CSS generation with metadata styles"
```

---

## Task 8: Add Integration Tests

**Files:**

- Create: `test/integration.test.ts`

**Step 1: Write integration tests**

Create `test/integration.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { codeToHighlightHtml } from '../src/index';

describe('Integration tests', () => {
  it('combines all features together', async () => {
    const code = `function hello() {
  console.log('world');
  return true;
}`;

    const result = await codeToHighlightHtml(code, {
      lang: 'javascript',
      lineNumbers: true,
      highlightLines: [1, 4],
      diffLines: { added: [2] },
      focusLines: [1, 2],
    });

    // Check HTML
    expect(result.html).toContain('line-number');
    expect(result.html).toContain('highlighted');
    expect(result.html).toContain('diff add');
    expect(result.html).toContain('blurred');

    // Check CSS
    expect(result.css).toContain('.line-number');
    expect(result.css).toContain('.highlighted');
    expect(result.css).toContain('.diff.add');
    expect(result.css).toContain('.blurred');

    // Check stats
    expect(result.stats.lines).toBe(4);
    expect(result.stats.tokens).toBeGreaterThan(10);
  });

  it('handles edge case: invalid line numbers', async () => {
    const code = 'line1\nline2';

    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      highlightLines: [1, 999], // 999 doesn't exist
    });

    // Should not throw, should only highlight valid lines
    expect(result.html).toContain('highlighted');
    expect(result.stats.lines).toBe(2);
  });

  it('handles edge case: empty code', async () => {
    const code = '';

    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      lineNumbers: true,
    });

    expect(result.html).toBeDefined();
    expect(result.stats.lines).toBe(1);
  });

  it('maintains performance with fast path', async () => {
    const code = 'const x = 1;';

    const start = performance.now();
    await codeToHighlightHtml(code, {
      lang: 'javascript',
    });
    const fastTime = performance.now() - start;

    expect(fastTime).toBeLessThan(100); // Should be very fast
  });

  it('parses line range syntax', async () => {
    const code = 'line1\nline2\nline3\nline4\nline5';

    const result = await codeToHighlightHtml(code, {
      lang: 'text',
      highlightLines: '1,3,5-7',
    });

    // Should highlight lines 1, 3, 5 (7 doesn't exist)
    expect(result.html).toContain('highlighted');
  });

  it('exports all public APIs', async () => {
    const { codeToHighlightHtml, codeToHtmlFallback, loadCustomLanguage } = await import(
      '../src/index'
    );

    expect(typeof codeToHighlightHtml).toBe('function');
    expect(typeof codeToHtmlFallback).toBe('function');
    expect(typeof loadCustomLanguage).toBe('function');
  });
});
```

**Step 2: Run test to verify it passes**

Run: `npm test test/integration.test.ts`
Expected: PASS - all tests pass

**Step 3: Commit**

```bash
git add test/integration.test.ts
git commit -m "test: add integration tests for transformer support"
```

---

## Task 9: Run Full Test Suite

**Files:**

- None (verification only)

**Step 1: Run all tests**

Run: `npm test`
Expected: All tests pass

**Step 2: Run coverage**

Run: `npm run test:coverage`
Expected: 100% coverage maintained

**Step 3: If coverage drops, identify gaps**

If coverage is not 100%, run:

```bash
npm run test:coverage -- --reporter=verbose
```

Identify uncovered lines and add tests to cover them.

**Step 4: Commit if tests added**

```bash
git add test/
git commit -m "test: achieve 100% coverage for transformer support"
```

---

## Task 10: Update Documentation

**Files:**

- Modify: `README.md`

**Step 1: Update README with transformer examples**

Add to README.md after the "Quick Start" section:

````markdown
## Transformer Support (v1.0.0)

### Line Numbers

```typescript
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  lineNumbers: true,
});

// Or start from specific line
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  lineNumbers: { start: 5 },
});
```
````

### Line Highlighting

```typescript
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  highlightLines: [1, 3, 5], // Array
});

// Or string syntax
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  highlightLines: '1,3,5-7', // String with ranges
});
```

### Diff Highlighting

```typescript
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  diffLines: {
    added: [2, 4],
    removed: [6, 8],
  },
});
```

### Focus/Blur

```typescript
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  focusLines: [1, 2, 3], // These stay in focus, others dimmed
});
```

### Advanced: Custom Transformers

```typescript
import { transformerNotationHighlight } from '@shikijs/transformers';

const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  transformers: [transformerNotationHighlight(), myCustomTransformer()],
});
```

### Combining Features

```typescript
const result = await codeToHighlightHtml(code, {
  lang: 'javascript',
  lineNumbers: true,
  highlightLines: [1, 3],
  diffLines: { added: [5] },
  focusLines: [1, 2, 3],
});
```

````

**Step 2: Commit**

```bash
git add README.md
git commit -m "docs: add transformer support examples to README"
````

---

## Task 11: Prepare for v1.0.0 Release

**Files:**

- Modify: `package.json`
- Create: `CHANGELOG.md`

**Step 1: Update version in package.json**

Update version to 1.0.0:

```json
{
  "version": "1.0.0"
}
```

**Step 2: Create CHANGELOG**

Create `CHANGELOG.md`:

```markdown
# Changelog

## [1.0.0] - 2025-01-12

### Added

- Full Shiki transformer support
- Line numbers with customizable start
- Line highlighting with range syntax (1,3,5-7)
- Diff highlighting (added/removed lines)
- Focus/blur regions
- Custom transformer support
- Meta string parsing in remark plugin

### Changed

- Graduated from 0.x (experimental) to 1.0.0 (stable)
- API remains 100% backward compatible
- Fast path preserved (no transformers = no overhead)

### Performance

- Maintains 80-90% DOM node reduction vs traditional Shiki
- Zero overhead for code without transformers

## [0.1.2] - Previous release

...
```

**Step 3: Commit**

```bash
git add package.json CHANGELOG.md
git commit -m "chore: bump version to 1.0.0"
```

---

## Task 12: Update Remark Plugin (Meta String Parsing)

**Files:**

- Modify: `../remark-shiki-highlight-api/src/index.ts`
- Create: `../remark-shiki-highlight-api/test/meta-parsing.test.ts`

**Step 1: Write tests for meta string parsing**

Create `../remark-shiki-highlight-api/test/meta-parsing.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { parseCodeMeta } from '../src/meta-parser';

describe('parseCodeMeta', () => {
  it('parses line highlight syntax', () => {
    expect(parseCodeMeta('{1,3,5}')).toEqual({
      highlightLines: [1, 3, 5],
    });
  });

  it('parses line range syntax', () => {
    expect(parseCodeMeta('{1-3}')).toEqual({
      highlightLines: [1, 2, 3],
    });
  });

  it('parses showLineNumbers flag', () => {
    expect(parseCodeMeta('showLineNumbers')).toEqual({
      lineNumbers: true,
    });
  });

  it('parses lineNumberStart', () => {
    expect(parseCodeMeta('lineNumberStart=5')).toEqual({
      lineNumbers: { start: 5 },
    });
  });

  it('parses combined meta string', () => {
    expect(parseCodeMeta('{1-3} showLineNumbers')).toEqual({
      highlightLines: [1, 2, 3],
      lineNumbers: true,
    });
  });

  it('ignores unknown attributes', () => {
    expect(parseCodeMeta('title="app.js" {1-2}')).toEqual({
      highlightLines: [1, 2],
    });
  });

  it('returns empty object for empty meta', () => {
    expect(parseCodeMeta('')).toEqual({});
    expect(parseCodeMeta(null)).toEqual({});
    expect(parseCodeMeta(undefined)).toEqual({});
  });
});
```

**Step 2: Run test to verify it fails**

Run: `cd ../remark-shiki-highlight-api && npm test test/meta-parsing.test.ts`
Expected: FAIL - parseCodeMeta not found

**Step 3: Implement meta parser**

Create `../remark-shiki-highlight-api/src/meta-parser.ts`:

```typescript
/**
 * Parse meta string from markdown code block
 * Supports: {1-3}, {1,3,5}, showLineNumbers, lineNumberStart=5
 */
export function parseCodeMeta(meta: string | null | undefined): {
  highlightLines?: number[];
  lineNumbers?: boolean | { start: number };
} {
  if (!meta) {
    return {};
  }

  const result: {
    highlightLines?: number[];
    lineNumbers?: boolean | { start: number };
  } = {};

  // Parse line highlighting: {1,3,5-7}
  const highlightMatch = meta.match(/\{([0-9,-]+)\}/);
  if (highlightMatch) {
    result.highlightLines = parseLineNumbers(highlightMatch[1]);
  }

  // Parse showLineNumbers flag
  if (meta.includes('showLineNumbers')) {
    result.lineNumbers = true;
  }

  // Parse lineNumberStart=N
  const startMatch = meta.match(/lineNumberStart=(\d+)/);
  if (startMatch) {
    result.lineNumbers = { start: parseInt(startMatch[1]) };
  }

  return result;
}

/**
 * Parse line numbers from string like "1,3,5-7"
 */
function parseLineNumbers(input: string): number[] {
  const lines = new Set<number>();

  input.split(',').forEach((part) => {
    const trimmed = part.trim();

    if (trimmed.includes('-')) {
      // Range: "1-3"
      const [start, end] = trimmed.split('-').map((n) => parseInt(n.trim()));
      if (!isNaN(start) && !isNaN(end)) {
        for (let i = start; i <= end; i++) {
          lines.add(i);
        }
      }
    } else {
      // Single number: "5"
      const num = parseInt(trimmed);
      if (!isNaN(num)) {
        lines.add(num);
      }
    }
  });

  return [...lines].sort((a, b) => a - b);
}
```

**Step 4: Run test to verify it passes**

Run: `cd ../remark-shiki-highlight-api && npm test test/meta-parsing.test.ts`
Expected: PASS - all tests pass

**Step 5: Update remark plugin to use meta parser**

In `../remark-shiki-highlight-api/src/index.ts`, update to parse meta strings:

```typescript
import { parseCodeMeta } from './meta-parser';

export function remarkHighlightApi(options: RemarkHighlightApiOptions = {}) {
  const { theme = 'dark-plus', loadLanguages, parseMetaString = true } = options;
  let languagesLoaded = false;

  return async (tree: Root) => {
    // Load custom languages once if provided
    if (loadLanguages && !languagesLoaded) {
      await loadLanguages();
      languagesLoaded = true;
    }

    // (existing language loading code...)

    // Process code blocks
    for (const { node, index, parent } of codeBlocks) {
      const lang = node.lang || 'text';
      const code = node.value;

      // Parse meta string if enabled
      const metaOptions = parseMetaString ? parseCodeMeta(node.meta) : {};

      try {
        const blockId = `hl-${++blockCounter}`;
        const result = await codeToHighlightHtml(code, {
          lang,
          theme,
          blockId,
          ...metaOptions, // Merge parsed meta options
        });

        // (rest of code block processing...)
      } catch (error) {
        console.error(`Failed to process code block (lang: ${lang}):`, error);
      }
    }
  };
}
```

**Step 6: Add interface for new options**

Update `RemarkHighlightApiOptions` interface:

```typescript
export interface RemarkHighlightApiOptions {
  theme?: string;
  loadLanguages?: () => Promise<void>;
  parseMetaString?: boolean; // NEW: default true
  transformers?: ShikiTransformer[]; // NEW: pass through
}
```

**Step 7: Run test to verify plugin works**

Run: `cd ../remark-shiki-highlight-api && npm test`
Expected: PASS - all tests pass

**Step 8: Commit**

```bash
cd ../remark-shiki-highlight-api
git add src/meta-parser.ts src/index.ts test/meta-parsing.test.ts
git commit -m "feat: add meta string parsing for transformer options"
```

---

## Task 13: Add Remark Plugin Integration Tests

**Files:**

- Create: `../remark-shiki-highlight-api/test/meta-integration.test.ts`

**Step 1: Write integration tests for meta strings**

Create `../remark-shiki-highlight-api/test/meta-integration.test.ts`:

````typescript
import { describe, it, expect } from 'vitest';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkRehype from 'remark-rehype';
import rehypeStringify from 'rehype-stringify';
import { remarkHighlightApi } from '../src/index';

describe('Meta string integration', () => {
  it('highlights lines from meta string', async () => {
    const markdown = '```javascript {1,3}\nline1\nline2\nline3\n```';

    const result = await unified()
      .use(remarkParse)
      .use(remarkHighlightApi)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown);

    const html = String(result);

    expect(html).toContain('highlighted');
  });

  it('shows line numbers from meta string', async () => {
    const markdown = '```javascript showLineNumbers\nconst x = 1;\n```';

    const result = await unified()
      .use(remarkParse)
      .use(remarkHighlightApi)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown);

    const html = String(result);

    expect(html).toContain('line-number');
  });

  it('combines multiple meta features', async () => {
    const markdown = '```javascript {1-2} showLineNumbers\nline1\nline2\n```';

    const result = await unified()
      .use(remarkParse)
      .use(remarkHighlightApi)
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown);

    const html = String(result);

    expect(html).toContain('highlighted');
    expect(html).toContain('line-number');
  });

  it('can disable meta parsing', async () => {
    const markdown = '```javascript {1}\nline1\n```';

    const result = await unified()
      .use(remarkParse)
      .use(remarkHighlightApi, { parseMetaString: false })
      .use(remarkRehype, { allowDangerousHtml: true })
      .use(rehypeStringify, { allowDangerousHtml: true })
      .process(markdown);

    const html = String(result);

    expect(html).not.toContain('highlighted');
  });
});
````

**Step 2: Run test to verify it passes**

Run: `cd ../remark-shiki-highlight-api && npm test test/meta-integration.test.ts`
Expected: PASS - all tests pass

**Step 3: Commit**

```bash
cd ../remark-shiki-highlight-api
git add test/meta-integration.test.ts
git commit -m "test: add meta string integration tests"
```

---

## Task 14: Update Remark Plugin Documentation

**Files:**

- Modify: `../remark-shiki-highlight-api/README.md`

**Step 1: Add meta string documentation**

Add to README after usage section:

`````markdown
## Meta String Support

The plugin automatically parses meta strings from code blocks:

### Line Highlighting

````markdown
```javascript {1,3,5-7}
// Line 1 is highlighted
const x = 1;
// Line 3 is highlighted
const y = 2;
// Lines 5-7 are highlighted
const z = 3;
const a = 4;
```
````
`````

`````

### Line Numbers

````markdown
```javascript showLineNumbers
const x = 1;  // Shows line numbers
const y = 2;
```
`````

Or start from specific line:

````markdown
```javascript lineNumberStart=5
const x = 1; // Line number shows 5
const y = 2; // Line number shows 6
```
````

### Combined

````markdown
```javascript {1-2} showLineNumbers
const x = 1; // Highlighted with line number
const y = 2; // Highlighted with line number
const z = 3; // Not highlighted but has line number
```
````

### Disable Meta Parsing

```javascript
export default defineConfig({
  markdown: {
    remarkPlugins: [[remarkHighlightApi, { parseMetaString: false }]],
  },
});
```

````

**Step 2: Commit**

```bash
cd ../remark-shiki-highlight-api
git add README.md
git commit -m "docs: add meta string support documentation"
````

---

## Task 15: Version Bump Remark Plugin

**Files:**

- Modify: `../remark-shiki-highlight-api/package.json`
- Create: `../remark-shiki-highlight-api/CHANGELOG.md`

**Step 1: Update version to 1.0.0**

Update `../remark-shiki-highlight-api/package.json`:

```json
{
  "version": "1.0.0"
}
```

**Step 2: Create CHANGELOG**

Create `../remark-shiki-highlight-api/CHANGELOG.md`:

```markdown
# Changelog

## [1.0.0] - 2025-01-12

### Added

- Meta string parsing (enabled by default)
- Automatic line highlighting from `{1-3}` syntax
- Line numbers from `showLineNumbers` flag
- Custom line number start from `lineNumberStart=N`

### Changed

- Upgraded shiki-highlight-api to v1.0.0
- Graduated to stable v1.0.0 release
- API remains 100% backward compatible

## [0.2.1] - Previous release

...
```

**Step 3: Update dependency version**

In `../remark-shiki-highlight-api/package.json`, update dependency:

```json
{
  "dependencies": {
    "shiki-highlight-api": "^1.0.0"
  }
}
```

**Step 4: Commit**

```bash
cd ../remark-shiki-highlight-api
git add package.json CHANGELOG.md
git commit -m "chore: bump version to 1.0.0"
```

---

## Completion Checklist

- [ ] All tests pass (both packages)
- [ ] 100% code coverage maintained
- [ ] Documentation updated
- [ ] CHANGELOGs created
- [ ] Versions bumped to 1.0.0
- [ ] Design document in docs/plans/
- [ ] Ready to publish to npm

## Success Criteria

 Full Shiki transformer support working
 Fast path preserved (no transformers = no overhead)
 Meta string parsing in remark plugin
 100% test coverage
 Backward compatible
 Both packages at v1.0.0
