import { visit } from 'unist-util-visit';
import type { Root as HastRoot, Element } from 'hast';
import { createEmptyMetadata, type Metadata } from './metadata';

/**
 * Extracts metadata from a HAST tree generated by Shiki transformers.
 * Walks the tree looking for line elements with semantic classes.
 */
export function extractMetadata(hast: HastRoot): Metadata {
  const metadata = createEmptyMetadata();

  visit(hast, 'element', (node: Element) => {
    // Only process line spans
    if (node.tagName !== 'span') return;

    const classes = getClassArray(node.properties.class);

    // Get line number from data-line attribute (added by Shiki)
    const dataLine = node.properties['data-line'];

    // If no data-line, check if this might be a line element via other indicators
    if (dataLine === undefined || dataLine === null) {
      // If we have line-numbered, process it even without data-line
      if (classes.includes('line-numbered')) {
        const dataLineNumber = node.properties['data-line-number'];
        if (dataLineNumber !== undefined) {
          const actualNumber = parseInt(String(dataLineNumber), 10);
          if (!isNaN(actualNumber)) {
            metadata.lineNumbers = { start: 1 }; // Default to starting at 1
          }
        }
      }
      return;
    }

    const lineNum = parseInt(String(dataLine), 10);
    if (isNaN(lineNum) || lineNum <= 0) return;

    // Detect line numbers feature
    if (classes.includes('line-numbered')) {
      const dataLineNumber = node.properties['data-line-number'];
      if (dataLineNumber !== undefined) {
        const actualNumber = parseInt(String(dataLineNumber), 10);
        if (!isNaN(actualNumber)) {
          // Calculate start number (first line number - first line index)
          const start = actualNumber - (lineNum - 1);
          metadata.lineNumbers = { start };
        }
      }
    }

    // Extract semantic information from classes
    if (classes.includes('highlighted')) {
      metadata.highlightedLines.add(lineNum);
    }

    if (classes.includes('diff')) {
      if (classes.includes('add')) {
        metadata.diffLines.added.add(lineNum);
      }
      if (classes.includes('remove')) {
        metadata.diffLines.removed.add(lineNum);
      }
    }

    if (classes.includes('focused') || classes.includes('has-focus')) {
      metadata.focusLines.add(lineNum);
    }

    // Capture all classes for this line
    metadata.lineClasses.set(lineNum, classes);

    // Parse inline styles if present
    if (node.properties.style) {
      const styles = parseInlineStyles(String(node.properties.style));
      if (Object.keys(styles).length > 0) {
        metadata.lineStyles.set(lineNum, styles);
      }
    }
  });

  return metadata;
}

/**
 * Converts class property to string array.
 * Handles both string and array formats.
 */
function getClassArray(classValue: unknown): string[] {
  if (Array.isArray(classValue)) {
    return classValue.map(String);
  }
  if (typeof classValue === 'string') {
    return classValue.split(' ').filter(Boolean);
  }
  return [];
}

/**
 * Parses inline CSS style string into object.
 * Example: "background-color: yellow; color: black;" -> { "background-color": "yellow", "color": "black" }
 */
function parseInlineStyles(styleString: string): Record<string, string> {
  const styles: Record<string, string> = {};

  // Split by semicolon, filter empty, trim
  const declarations = styleString
    .split(';')
    .map((s) => s.trim())
    .filter(Boolean);

  for (const declaration of declarations) {
    const colonIndex = declaration.indexOf(':');
    if (colonIndex === -1) continue;

    const property = declaration.slice(0, colonIndex).trim();
    const value = declaration.slice(colonIndex + 1).trim();

    if (property && value) {
      styles[property] = value;
    }
  }

  return styles;
}
